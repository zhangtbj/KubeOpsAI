package controller

import (
	"context"
	"github.com/go-logr/logr"
	"github.com/zhangtbj/KubeOpsAI/pkg/apis/core/v1alpha1"
	"k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"time"
)

// QuestionReconciler reconciles a Question object
type QuestionReconciler struct {
	client.Client
	Log logr.Logger
}

// +kubebuilder:rbac:groups=core.kubeopsai.ai,resources=questions,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=core.kubeopsai.ai,resources=questions/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=core.kubeopsai.ai,resources=questions/finalizers,verbs=update

func (r *QuestionReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
	log := r.Log.WithValues("question", req.NamespacedName)

	// Fetch the Question instance
	question := &v1alpha1.Question{}
	if err := r.Get(ctx, req.NamespacedName, question); err != nil {
		if errors.IsNotFound(err) {
			// Object not found, return. Created objects are automatically garbage collected.
			return ctrl.Result{}, nil
		}
		// Error reading the object - requeue the request.
		return ctrl.Result{}, err
	}

	// Check if the question has been answered
	if question.Status.Answer == "" {
		// Example: Answer the question
		question.Status.Answer = "Sample answer generated by the controller"
		question.Status.Phase = "Answered"
		question.Status.Message = "The question has been processed successfully."
		question.Status.LastUpdated = metav1.Now()

		// Update the status
		if err := r.Status().Update(ctx, question); err != nil {
			log.Error(err, "Failed to update Question status")
			return ctrl.Result{}, err
		}
	}

	// Reconcile every 5 minutes
	return ctrl.Result{RequeueAfter: time.Minute * 5}, nil
}

func (r *QuestionReconciler) SetupWithManager(mgr ctrl.Manager) error {
	return ctrl.NewControllerManagedBy(mgr).
		For(&v1alpha1.Question{}).
		Complete(r)
}
